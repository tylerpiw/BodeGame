<!doctype html>
<html>

<head>
    <title>Bode Game 3-9-2021</title>
    <script src="https://www.chartjs.org/dist/2.7.3/Chart.bundle.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.2.0/math.min.js" integrity="sha512-5ch7MAn3LJHCHL6ri6nmXAyaQRHfmug70F7IwEQ41rnNQSGAMVyZBPTTKlaptPnq/42RXbKb/lTHm+mCQc6lPg==" crossorigin="anonymous"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        canvas{
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
        .chart-container {
            width: 750px;
            margin-left: 40px;
            margin-right: 40px;
            margin-bottom: 40px;
        }
        .container {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
        }
    </style>
</head>

<body>
<h2>Instruction:</h2>
<p>The website will automatically generate a puzzle, observe both the magnitude plot and the phase plot carefully.</p>
<p>Then, use the input boxes below to add zeros and poles to create a system that matches the puzzle. </p>
<p>Notice that the puzzle can be consisted of both first order systems and second order systems. Use the according input boxes to solve the puzzle. </p>
<p>The bar chart indicates the percentage match.</p>
<p>You may proceed to the next level by using the NEXT LEVEL button. </p>
<p id = "transferFun"> </p>
<!--<div style="width:75%;">-->
<!--<canvas id="canvas"></canvas>-->
<!--</div>-->
<button id="addPole1">Add Pole 1st</button> Location: <input type="text" id="poleLoc1"/><br>
<button id="addZero1">Add Zero 1st</button> Location: <input type="text" id="zeroLoc1"/><br>
<button id="addPole2">Add Pole 2nd</button> First Root: <input type="text" id="poleLoc2_1"/> Second Root:<input type="text" id="poleLoc2_2"/><br>
<button id="addZero2">Add Zero 2nd</button> First Root: <input type="text" id="zeroLoc2_1"/> Second Root:<input type="text" id="zeroLoc2_2"/><br>
<button id="addComplexPole">Add Complex Pole</button> Real Part: <input type="text" id="cplxp_real"/> Imaginary Part: <input type="text" id="cplxp_ima"/><br>
<button id="addComplexZero">Add Complex Zero</button> Real Part: <input type="text" id="cplxz_real"/> Imaginary Part: <input type="text" id="cplxz_ima"/><br>
<button id="removeDataset">Remove Dataset</button>
<button id="nextLevel">Next Level</button> <br>


<div class="container">
    <div class="chart-container">
        <canvas id="score plot"></canvas>
    </div>
    <div class="chart-container">
        <canvas id="magnitude plot"></canvas>
    </div>
    <div class="chart-container">
        <canvas id="phase plot"></canvas>
    </div>
</div>


<script>
    var clicks= 0;
    var label = makeLogArr(-3,3,25)
    window.chartColors = {
        red: 'rgb(255, 99, 132)',
        orange: 'rgb(255, 159, 64)',
        yellow: 'rgb(255, 205, 86)',
        green: 'rgb(75, 192, 192)',
        blue: 'rgb(54, 162, 235)',
        purple: 'rgb(153, 102, 255)',
        grey: 'rgb(231,233,237)'
    };
    var colorNames = Object.keys(window.chartColors);
    var matchPercentage;
    var omega_p1 =[];
    var omega_z1 =[];
    var omega_p2 =[];
    var omega_z2 =[];
    var omega_cp =[];
    var omega_cz =[];
    var firstPoleInput = [];
    var firstZeroInput = [];
    var secPoleInput = [];
    var secZeroInput = [];
    var compPoleInput = [];
    var compZeroInput = [];

    var configMag = {
        type: 'line',
        data: {
            labels: label.toString().split(','),
            datasets:[]
        },
        options: {
            responsive: true,
            title: {
                display: true,
                text: 'Magnitude Plot'
            },
            tooltips: {
                mode: 'index',
                intersect: false,
            },
            hover: {
                mode: 'nearest',
                intersect: true
            },
            scales: {
                xAxes: [{
                    display: true,
                    type: 'logarithmic',
                    scaleLabel: {
                        display: true,
                        labelString: 'omega [rad/s]'
                    }
                }],
                yAxes: [{

                    display: true,
                    scaleLabel: {
                        display: true,
                        labelString: 'f(x) [dB]'
                    }
                }]
            }
        }
    };


    var configPhase = {
        type: 'line',
        data: {
            labels: label.toString().split(','),
            datasets:[],
        },
        options: {
            responsive: true,
            title: {
                display: true,
                text: 'Phase Plot'
            },
            tooltips: {
                mode: 'index',
                intersect: false,
            },
            hover: {
                mode: 'nearest',
                intersect: true
            },
            scales: {
                xAxes: [{
                    display: true,
                    type: 'logarithmic',
                    scaleLabel: {
                        display: true,
                        labelString: 'omega [rad/s]'
                    }
                }],
                yAxes: [{
                    display: true,
                    scaleLabel: {
                        display: true,
                        labelString: 'PHI [deg]'
                    }
                }]
            }
        }
    };

    var configScore = {
        type: 'doughnut',
        data: {
            datasets: [{
                data: [],
                backgroundColor: [
                    window.chartColors.green,
                    window.chartColors.orange,
                ],
                label: 'Score'
            }],
            labels: [
                'Percent Match',
                'Percent Mismatch',
            ]
        },
        options: {
            responsive: true,
            legend: {
                position: 'top',
            },
            title: {
                display: true,
                text: 'Score'
            },
            animation: {
                animateScale: true,
                animateRotate: true
            }
        }
    };



    window.onload = function() {
        var ctxMag = document.getElementById('magnitude plot').getContext('2d');
        window.myLineMag = new Chart(ctxMag, configMag);
        var ctxPhase = document.getElementById('phase plot').getContext('2d');
        window.myLinePhase = new Chart(ctxPhase, configPhase);
        var ctxScore = document.getElementById('score plot').getContext('2d');
        window.myDoughnutScore = new Chart(ctxScore, configScore);
        generatePuzzle1Pole();

    };

    document.getElementById('addPole1').addEventListener('click', function() {
        var poleLoc1 = document.getElementById('poleLoc1').value;
        addPole(poleLoc1);
    });

    document.getElementById('addPole2').addEventListener('click', function() {
        var poleLoc2_1 = document.getElementById('poleLoc2_1').value;
        var poleLoc2_2 = document.getElementById('poleLoc2_2').value;
        addPole2(poleLoc2_1,poleLoc2_2);
    });
    document.getElementById('addZero1').addEventListener('click', function() {
        var zeroLoc1 = document.getElementById('zeroLoc1').value;
        addZero(zeroLoc1);
    });

    document.getElementById('addZero2').addEventListener('click', function() {
        var zeroLoc2_1 = document.getElementById('zeroLoc2_1').value;
        var zeroLoc2_2 = document.getElementById('zeroLoc2_2').value;
        addZero2(zeroLoc2_1,zeroLoc2_2);
    });
    document.getElementById('addComplexPole').addEventListener('click',function (){
        var complexPole_real = document.getElementById('cplxp_real').value;
        var complexPole_ima = document.getElementById('cplxp_ima').value;
        addCplxPole(complexPole_real,complexPole_ima);
    });
    document.getElementById('addComplexZero').addEventListener('click',function (){
       var complexZero_real = document.getElementById('cplxz_real').value;
       var complexZero_ima = document.getElementById('cplxz_ima').value;
        addCplxZero(complexZero_real,complexZero_ima);
    });
    document.getElementById('removeDataset').addEventListener('click', function() {
        removeDataset();
    });
    document.getElementById('nextLevel').addEventListener('click', function() {
        levelComplete();


    });
    function levelDetermine() {
        switch (clicks) {
            case 0:
                alert('Take your time and try again before moving on');
                break;
            case 1:
            case 2:
                moreDoughnut();
                removeAll();
                generatePuzzle1Pole();
                break;
            case 3:
                removeAllDoughnut();
                removeAll();
                moreDoughnut();
                generatePuzzle1Zero();
                break;
            case 4:
            case 5:
                moreDoughnut();
                removeAll();
                generatePuzzle1Zero();
                break;
            case 6:
                removeAllDoughnut();
                moreDoughnut();
                removeAll();
                generatePuzzle1Pole1Zero();
                break;
            case 7:
            case 8:
                moreDoughnut();
                removeAll();
                generatePuzzle1Pole1Zero();
                break;
            case 9:
                removeAll();
                removeAllDoughnut();
                moreDoughnut();
                generatePuzzle2Pole();
                break;
            case 10:
            case 11:
                moreDoughnut();
                removeAll();
                generatePuzzle2Pole();
                break;
            case 12:
                removeAll();
                removeAllDoughnut();
                moreDoughnut();
                generatePuzzle2Pole1Zero();
                break;
            case 13:
            case 14:
                moreDoughnut();
                removeAll();
                generatePuzzle2Pole1Zero();
                break;
            case 15:
                removeAll();
                removeAllDoughnut();
                moreDoughnut();
                generatePuzzle2Pole2Zero();
                break;
            case 16:
            case 17:
                moreDoughnut();
                removeAll();
                generatePuzzle2Pole2Zero();
                break;
            case 18:
                removeAll();
                removeAllDoughnut();
                moreDoughnut();
                generateComplexPole();
                break;
            case 19:
            case 20:
                removeAll();
                moreDoughnut();
                generateComplexPole();
                break;
                //tbc
            case 21:
                removeAll();
                removeAllDoughnut();
                moreDoughnut();
                generateComplexPole();
                break;
            case 22:
            case 23:
                removeAll();
                moreDoughnut();
                generateComplexPole();
                break;
            case 24:
                removeAll();
                removeAllDoughnut();
                moreDoughnut();
                generateComplexZero();
                break;
            case 25:
            case 26:
                removeAll();
                moreDoughnut();
                generateComplexZero();
                break;

            //default:
              //  removeAll();
                //removeAllDoughnut();
                //generatePuzzleNew();

        }
    }

    function levelComplete() {

        if (matchPercentage> 80){
            clicks += 1;
            alert("Noice")
            levelDetermine();
        }
        else {
            alert("Try Again")

        }

    }

    function generatePuzzle1Pole(){
        resetInput();
        var newDatasetMag = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };

        var newDatasetPhase = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        }
        var omega = makeLogArr(-3,3,67);
        var randomPoleLoc = -Math.pow(10, (Math.random() - 0.5) * 2 * 3);
        var omegac = -randomPoleLoc;
        var magNPhase = makeFirstOrder(omega,omegac,true);
        newDatasetMag.data = magNPhase[0];
        newDatasetPhase.data = magNPhase[1];

        configMag.data.datasets.push(newDatasetMag);
        configPhase.data.datasets.push(newDatasetPhase);

        window.myLineMag.update();
        window.myLinePhase.update();

        sumDatasets();
        calculateScore();


    }
    function generatePuzzle1Zero(){
        resetInput();
        var newDatasetMag = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };

        var newDatasetPhase = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        }
        var omega = makeLogArr(-3,3,67);
        var randomPoleLoc = -Math.pow(10, (Math.random() - 0.5) * 2 * 3);
        var omegac = -randomPoleLoc;
        var magNPhase = makeFirstOrder(omega,omegac,false);
        newDatasetMag.data =magNPhase[0];
        newDatasetPhase.data= magNPhase[1];

        configMag.data.datasets.push(newDatasetMag);
        configPhase.data.datasets.push(newDatasetPhase);

        window.myLineMag.update();
        window.myLinePhase.update();


        sumDatasets();
        calculateScore();

    }
    function generatePuzzle1Pole1Zero(){
        resetInput();
        var omega = makeLogArr(-3,3,67);
        var randomPoleLoc2 = -Math.pow(10, (Math.random() - 0.5) * 2 * 3);
        var omegac = -randomPoleLoc2;
        var magNPhase_p = makeFirstOrder(omega,omegac,true);
        var mag_p =magNPhase_p[0] ;
        var phase_p = magNPhase_p[1];



        var randomPoleLoc1 = -Math.pow(10, (Math.random() - 0.5) * 2 * 3);
        var omegac = -randomPoleLoc1;
        var magNPhase_z = makeFirstOrder(omega,omegac,false);
        var mag_z = magNPhase_z[0];
        var phase_z= magNPhase_z[1];


        var newDatasetMag = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };

        var newDatasetPhase = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };

        var magTotal =[];
        var phaseTotal = [];
        //summing up the puzzle data sets
        for (var i = 0; i < omega.length; ++i) {
            var magSum = {x: omega[i], y:(mag_z[i].y + mag_p[i].y)};
            magTotal.push(magSum);
            var phaseSum = {x: omega[i], y: (phase_z[i].y + phase_p[i].y)};
            phaseTotal.push(phaseSum);
        }
        newDatasetMag.data = magTotal;
        newDatasetPhase.data = phaseTotal;
        configMag.data.datasets.push(newDatasetMag);
        configPhase.data.datasets.push(newDatasetPhase);

        window.myLineMag.update();
        window.myLinePhase.update();
        sumDatasets();
        calculateScore();



    }
    function generatePuzzle2Pole(){
        resetInput();
        var newDatasetMag = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };

        var newDatasetPhase = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };
        var randomNatural = randomInteger(0.001,1000);
        var randomDamp = Math.random();
        var omega = changeSamplingRate(randomDamp,randomNatural);
        var magNPhase = makeSecondOrder(omega,randomNatural,randomDamp,true);
            newDatasetMag.data = magNPhase[0];
            newDatasetPhase.data =magNPhase[1];

        configMag.data.datasets.push(newDatasetMag);
        configPhase.data.datasets.push(newDatasetPhase);


        window.myLineMag.update();
        window.myLinePhase.update();
        sumDatasets();
        calculateScore();


    }

        function  generatePuzzle2Pole1Zero(){
            resetInput();
            var randomNatural = randomInteger(0.001,1000);
            var randomDamp = Math.random();
            var omega = changeSamplingRate(randomDamp,randomNatural);

            var magNPhase2 = makeSecondOrder(omega,randomNatural,randomDamp,true);
            var mag2 =magNPhase2[0];
            var phase2 = magNPhase2[1];


            var randomPoleLoc = -Math.pow(10, (Math.random() - 0.5) * 2 * 3);
            var omegac = -randomPoleLoc;
            var magNPhase1 = makeFirstOrder(omega,omegac,false);
            var mag1 =magNPhase1[0];
            var phase1 = magNPhase1[1];

            var newDatasetMag = {
                label: 'Puzzle ',
                borderWidth: 6,
                cubicInterpolationMode: 'monotone',
                backgroundColor: 'rgb(128,128,128)',
                borderColor: 'rgb(128,128,128)',
                borderDash: [5, 5],
                data: [],
                fill: false
            };

            var newDatasetPhase = {
                label: 'Puzzle ',
                borderWidth: 6,
                cubicInterpolationMode: 'monotone',
                backgroundColor: 'rgb(128,128,128)',
                borderColor: 'rgb(128,128,128)',
                borderDash: [5, 5],
                data: [],
                fill: false
            };
            var magTotal =[];
            var phaseTotal = [];
            //summing up the puzzle data sets
            for (var i = 0; i < omega.length; ++i) {
                var magSum = {x: omega[i], y:(mag2[i].y + mag1[i].y)};
                magTotal.push(magSum);
                var phaseSum = {x: omega[i], y: (phase2[i].y + phase1[i].y)};
                phaseTotal.push(phaseSum);
            }
                newDatasetMag.data = magTotal;
                newDatasetPhase.data = phaseTotal;

            configMag.data.datasets.push(newDatasetMag);
            configPhase.data.datasets.push(newDatasetPhase);

            window.myLineMag.update();
            window.myLinePhase.update();
            sumDatasets();
            calculateScore();


        }
    function generatePuzzle2Pole2Zero(){
        resetInput();
        //make pole omega
        var randomNatural_p = randomInteger(0.001,1000);
        var randomDamp_p = Math.random();
        var omega_p = makePeakArray(randomDamp_p,randomNatural_p);
        //make zero omega

        var randomNatural_z = randomInteger(0.001,1000);
        var randomDamp_z = Math.random();
        var omega_z = makePeakArray(randomDamp_z,randomNatural_z);
        // combine omega
        var omega_25 = makeLogArr(-3,3,25);
        var omega_trans = addPeak(omega_25,omega_p);
        var omega_final = addPeak(omega_trans, omega_z);
        var magNPhase_z = makeSecondOrder(omega_final,randomNatural_z,randomDamp_z,false);
        var mag_z =magNPhase_z[0];
        var phase_z = magNPhase_z[1];
        var magNPhase_p = makeSecondOrder(omega_final,randomNatural_p,randomDamp_p,true);
        var mag_p =magNPhase_p[0];
        var phase_p = magNPhase_p[1];

        var newDatasetMag = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };

        var newDatasetPhase = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };
        var magTotal =[];
        var phaseTotal = [];
        //summing up the puzzle data sets
        for (var i = 0; i < omega_final.length; ++i) {
            var magSum = {x: omega_final[i], y:(mag_z[i].y + mag_p[i].y)};
            magTotal.push(magSum);
            var phaseSum = {x: omega_final[i], y: (phase_z[i].y + phase_p[i].y)};
            phaseTotal.push(phaseSum);
        }
        newDatasetMag.data = magTotal;
        newDatasetPhase.data = phaseTotal;

        configMag.data.datasets.push(newDatasetMag);
        configPhase.data.datasets.push(newDatasetPhase);



        window.myLineMag.update();
        window.myLinePhase.update();
        sumDatasets();
        calculateScore();


    }

    function generateComplexPole(){

        var pole_real = (Math.random()*10)*Math.random()**(-Math.random()*10);
        var pole_ima = randomInteger(1,1000);
        var a = math.complex(pole_real,pole_ima);
        var b = math.complex(pole_real,-pole_ima);
        var naturalFreq= Math.pow(math.multiply(a,b),0.5);
        var dampRatio = pole_real/(2*naturalFreq);
        var omega = changeSamplingRate(dampRatio,naturalFreq);
        var magNphase = makeSecondOrder(omega, naturalFreq, dampRatio,true);
        var mag = magNphase[0];
        var phase = magNphase[1];

        var newDatasetMag = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };

        var newDatasetPhase = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };
        newDatasetMag.data = mag;
        newDatasetPhase.data = phase;

        configMag.data.datasets.push(newDatasetMag);
        configPhase.data.datasets.push(newDatasetPhase);

        window.myLineMag.update();
        window.myLinePhase.update();
        sumDatasets();
        calculateScore();


    }

    function generateComplexZero(){

        var zero_real = (Math.random()*10)*Math.random()**(-Math.random()*10);
        var zero_ima = randomInteger(1,1000);
        var a = math.complex(zero_real,zero_ima);
        var b = math.complex(zero_real,-zero_ima);
        var naturalFreq= Math.pow(math.multiply(a,b),0.5);
        var dampRatio = pole_real/(2*naturalFreq);
        var omega = changeSamplingRate(dampRatio,naturalFreq);
        var magNphase = makeSecondOrder(omega, naturalFreq, dampRatio,false);
        var mag = magNphase[0];
        var phase = magNphase[1];

        var newDatasetMag = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };

        var newDatasetPhase = {
            label: 'Puzzle ',
            borderWidth: 6,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(128,128,128)',
            borderColor: 'rgb(128,128,128)',
            borderDash: [5, 5],
            data: [],
            fill: false
        };
        newDatasetMag.data = mag;
        newDatasetPhase.data = phase;

        configMag.data.datasets.push(newDatasetMag);
        configPhase.data.datasets.push(newDatasetPhase);

        window.myLineMag.update();
        window.myLinePhase.update();
        sumDatasets();
        calculateScore();

    }


    function addPole(poleLoc1) {
        var omegac = -poleLoc1;
        var omegac_power = Math.log10(omegac);
        firstPoleInput.push(poleLoc1);
        var colorName = colorNames[configMag.data.datasets.length % colorNames.length];
        var newColor = window.chartColors[colorName];


        var newDatasetMag = {
            label: '1st order pole',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            pointRadius: 0,
            data: [],
            fill: false
        };

        var newDatasetPhase = {
            label: 'Pole: 10^' + parseFloat(omegac_power).toFixed(2)  + ' [rad/s]',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            pointRadius: 0,
            data: [],
            fill: false
        };
        omega_p1 = makeLogArr(-3,3,25);
        var magNPhase = makeFirstOrder(omega_p1,omegac,true);
            newDatasetMag.data = magNPhase[0];
            newDatasetPhase.data = magNPhase[1];

        removeSumDataset();

        configMag.data.datasets.push(newDatasetMag);
        window.myLineMag.update();

        configPhase.data.datasets.push(newDatasetPhase);
        window.myLinePhase.update();

        sumDatasets();

    }

    function addZero(zeroLoc1) {
        var omegac = -zeroLoc1;
        var omegac_power = Math.log10(omegac);
        firstZeroInput.push(zeroLoc1);
        var colorName = colorNames[configMag.data.datasets.length % colorNames.length];
        var newColor = window.chartColors[colorName];


        var newDatasetMag = {
            label: '1st order zero',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            pointRadius: 0,
            borderColor: newColor,
            data: [],

            fill: false
        };

        var newDatasetPhase = {
            label: 'Zero: 10^' + parseFloat(omegac_power).toFixed(2)  + ' [rad/s]',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            pointRadius: 0,
            data: [],
            fill: false
        };

        omega_z1 = makeLogArr(-3,3,25);
        var magNPhase = makeFirstOrder(omega_z1,omegac,false);
        newDatasetMag.data = magNPhase[0];
        newDatasetPhase.data = magNPhase[1];


        removeSumDataset();

        configMag.data.datasets.push(newDatasetMag);
        window.myLineMag.update();

        configPhase.data.datasets.push(newDatasetPhase);
        window.myLinePhase.update();

        sumDatasets();



    }


    function addPole2(poleLoc2_1,poleLoc2_2){
        var pole1 =-poleLoc2_1;
        var pole2 =-poleLoc2_2
        var naturalFreq= Math.pow(pole1*pole2,0.5);
        var dampRatio = (pole2+pole1)/(2*naturalFreq);
        secPoleInput.push({first:poleLoc2_1, second:poleLoc2_2});

        var colorName = colorNames[configMag.data.datasets.length % colorNames.length];
        var newColor = window.chartColors[colorName];

        omega_p2 = changeSamplingRate(dampRatio,naturalFreq);
        var magNPhase = makeSecondOrder(omega_p2,naturalFreq,dampRatio,true);


        var newDatasetMag = {
            label: '2nd order pole',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            pointRadius: 0,
            data: [],
            fill: false
        };

        var newDatasetPhase = {
            label: 'Pole: 10^' + parseFloat(poleLoc2_1).toFixed(2)  + ' [rad/s]'+ 'and'+ 'Pole: 10^' +parseFloat(poleLoc2_2).toFixed(2) + ' [rad/s]',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            pointRadius: 0,
            data: [],
            fill: false
        };
        newDatasetMag.data = magNPhase[0];

        newDatasetPhase.data =magNPhase[1];

        removeSumDataset();

        configMag.data.datasets.push(newDatasetMag);
        window.myLineMag.update();

        configPhase.data.datasets.push(newDatasetPhase);
        window.myLinePhase.update();

        sumDatasets();


    }

    function addZero2(zeroLoc2_1,zeroLoc2_2){
        var zero1 = -zeroLoc2_1;
        var zero2 = -zeroLoc2_2;
        var naturalFreq= Math.pow(zero1*zero2,0.5);
        var dampRatio = (zero2+zero1)/(2*naturalFreq);
        secZeroInput.push({first:zeroLoc2_1, second:zeroLoc2_2});
        var colorName = colorNames[configMag.data.datasets.length % colorNames.length];
        var newColor = window.chartColors[colorName];



        var newDatasetMag = {
            label: '2nd order zero',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            data: [],
            pointRadius: 0,
            fill: false
        };

        var newDatasetPhase = {
            label: 'Zero: 10^' + parseFloat(zeroLoc2_1).toFixed(2)  + ' [rad/s]'+ 'and'+ 'Zero: 10^' +parseFloat(zeroLoc2_2).toFixed(2) + ' [rad/s]',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            data: [],
            pointRadius: 0,
            fill: false
        };
        omega_z2 = changeSamplingRate(dampRatio,naturalFreq);
        var magNPhase = makeSecondOrder(omega_z2,naturalFreq,dampRatio,false);
        newDatasetMag.data = magNPhase[0];

        newDatasetPhase.data =magNPhase[1];


        removeSumDataset();

        configMag.data.datasets.push(newDatasetMag);
        window.myLineMag.update();

        configPhase.data.datasets.push(newDatasetPhase);
        window.myLinePhase.update();

        sumDatasets();


    }

    function addCplxPole(complexPole_real,complexPole_ima){
        var pole_real = complexPole_real;
        var pole_ima = complexPole_ima;
        var a = math.complex(pole_real,pole_ima);
        var b = math.complex(pole_real,-pole_ima);
        var naturalFreq= Math.pow(math.multiply(a,b),0.5);
        var dampRatio = Math.abs(pole_real/(2*naturalFreq));

        compPoleInput.push({real:complexPole_real,imag :complexPole_ima});
        var colorName = colorNames[configMag.data.datasets.length % colorNames.length];
        var newColor = window.chartColors[colorName];


        var newDatasetMag = {
            label: 'complex pole',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            data: [],
            pointRadius: 0,
            fill: false
        };

        var newDatasetPhase = {
            label: 'Pole: 10^' + parseFloat(pole_real).toFixed(2) + '\xB1' + parseFloat(pole_ima).toFixed(2) +'[rad/s]',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            data: [],
            pointRadius: 0,
            fill: false
        };
        omega_cp = changeSamplingRate(dampRatio,naturalFreq);
        var magNPhase = makeSecondOrder(omega_cp,naturalFreq,dampRatio,true);

        newDatasetMag.data = magNPhase[0];

        newDatasetPhase.data =magNPhase[1];

        removeSumDataset();

        configMag.data.datasets.push(newDatasetMag);
        window.myLineMag.update();

        configPhase.data.datasets.push(newDatasetPhase);
        window.myLinePhase.update();

        sumDatasets();

    }

    function  addCplxZero(complexZero_real,complexZero_ima){
        var zero_real = complexZero_real;
        var zero_ima = complexZero_ima;
        var a = math.complex(zero_real,zero_ima);
        var b = math.complex(zero_real,-zero_ima);
        var naturalFreq= Math.pow(math.multiply(a,b),0.5);
        var dampRatio = Math.abs((zero_real)/(2*naturalFreq));
        var colorName = colorNames[configMag.data.datasets.length % colorNames.length];
        var newColor = window.chartColors[colorName];
        compZeroInput.push({real:complexZero_real,imag :complexZero_ima});

        var newDatasetMag = {
            label: 'complex zero',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            data: [],
            pointRadius: 0,
            fill: false
        };

        var newDatasetPhase = {
            label: 'Zero: 10^' + parseFloat(zero_real).toFixed(2)  + '\xB1' +parseFloat(zero_ima).toFixed(2) + ' [rad/s]',
            cubicInterpolationMode: 'monotone',
            backgroundColor: newColor,
            borderColor: newColor,
            data: [],
            pointRadius: 0,
            fill: false
        };

        omega_cz = changeSamplingRate(dampRatio,naturalFreq);
        var magNPhase = makeSecondOrder(omega_cz,naturalFreq,dampRatio,false);
        newDatasetMag.data = magNPhase[0];

        newDatasetPhase.data =magNPhase[1];


        removeSumDataset();

        configMag.data.datasets.push(newDatasetMag);
        window.myLineMag.update();

        configPhase.data.datasets.push(newDatasetPhase);
        window.myLinePhase.update();

        sumDatasets();

    }
    function changeSamplingRate(dampRatio, naturalFreq) {
        var arr = makeLogArr(-3,3,25);
        var peakArr = makePeakArray(dampRatio, naturalFreq);
        var newArr = arr.concat(peakArr)
        newArr.sort((a, b) => a - b);
        removeDuplicates(newArr);
        return newArr

    }

    function makePeakArray (dampRatio,naturalF){
        var arr = [];
        const N =80;
        var beta = (Math.pow(2*dampRatio*Math.sqrt(1-dampRatio**2),2))/0.707**2;
        var alpha = Math.sqrt(Math.pow((4*dampRatio**2-2),2)-4*(1-beta))/2
        var halfP2 = naturalF*Math.sqrt((1-2*dampRatio**2)+alpha);
        var halfP1 = naturalF*Math.sqrt((1-2*dampRatio**2)-alpha);
        console.log(halfP1);
        console.log(halfP2);
        console.log(naturalF);
        var step1 = (naturalF - halfP1)/ N;
        var step2 = (halfP2 - naturalF)/ N;
            for (var i = 0; i<N; i++){
                arr.push(halfP1 + step1*i);
            }
            for (var i = 0; i<= N; i++){
                arr.push(naturalF + step2 *i);
            }
        return arr;
    }

    function addPeak (arr, peakArr) {

        var newArr = arr.concat(peakArr);
        newArr.sort((a, b) => a - b);
        removeDuplicates(newArr);
        return newArr

    }

    function removeDuplicates(array) {
        array.splice(0, array.length, ...(new Set(array)))
    }

    function makeLogArr(startValue, stopValue, cardinality) {
        var arr = [];
        var currValue = startValue;
        var step = (stopValue - startValue) / (cardinality - 1);
        for (var i = 0; i < cardinality; i++) {
            arr.push(Math.pow(10,(currValue + (step * i))));
        }

        return arr;
    }


    function randomInteger(min, max) {
        var mid = (min+max)/900;
        var factor = Math.random();
        if (factor > 0.5){
            var random = Math.random() * (mid - min + 1) + min
        }
        else{
            var random = Math.random() * (max - mid + 1) + min
        }
        return random;
    }

    function calculateScore() {
        //var omega = omega_p1.concat(omega_z1,omega_p2,omega_z2,omega_cp,omega_cz);
        // omega.sort((a, b) => a - b);
       // omega.splice(0, omega.length, ...(new Set(omega)));
       // var sumIndex = configMag.data.datasets.length-1; //sum dataset should be final dataset (last index = length of dataset)
        var xPuzzle = configPhase.data.datasets[0].data.map(a => a.x); //get the xvalue of puzzle
        var newSum = rebuild(xPuzzle,true)[1]//rebuild of sum

       // for (var i = 0; i<sameSamples.length; ++i){
          //  indexPuzzle.push(xPuzzle.indexOf(sameSamples[i]));
          //  indexSum.push(xSum.indexOf(sameSamples[i]));
        //}

        //var yPuzzle =[];// find y of the puzzle thru index
        //var ySum = []; //find y of the sum thru index

        //for (var i = 0; i<indexPuzzle.length; ++i){
          // yPuzzle.push(configPhase.data.datasets[0].data[indexPuzzle[i]].y);}
       // for (var i = 0; i<indexSum.length; ++i){
          // ySum.push(configPhase.data.datasets[sumIndex].data[indexSum[i]].y);

        //for (let i = 0; i<xPuzzle.length; ++i){
        //    let tempNewPuzzle ={x:xPuzzle[i], y: yPuzzle[i]};
       //     newPuzzle.push(tempNewPuzzle);
      //      let tempNewSum = {x:xPuzzle[i], y: ySum[i]};
       //     newSum.push(tempNewSum);
      //  }

        var sumPuzzleSquaredPhase = 0; //adding up squared deviation of puzzle phase plot from zero. This forms a basis to get percentage difference

        for (var i = 0; i < newSum.length; ++i) {
            sumPuzzleSquaredPhase += Math.pow(newSum[i].y,2); //sum of squares of phase of puzzle plot
        }
        var tempSquaredDifference = 0; //adding up squared differences in phase plot
        var phaseDiff = 0; //getting phase difference between sum line and puzzle line

        for (var i = 0; i < xPuzzle.length; ++i) {
            phaseDiff = newSum[i].y - configPhase.data.datasets[0].data[i].y;
            tempSquaredDifference += Math.pow(phaseDiff,2);
        }
        //
        matchPercentage = 100*(sumPuzzleSquaredPhase-tempSquaredDifference)/sumPuzzleSquaredPhase;
        var mismatchPercentage = 100 - matchPercentage;
        //
        //
        if(Number.isFinite(matchPercentage)===false){
            configScore.data.datasets[configScore.data.datasets.length-1].data[0] = 0;
            configScore.data.datasets[configScore.data.datasets.length-1].data[1] = 100;
        }
        else {
            configScore.data.datasets[configScore.data.datasets.length-1].data[0] = matchPercentage;
            configScore.data.datasets[configScore.data.datasets.length-1].data[1] = mismatchPercentage;
        }

        window.myDoughnutScore.update();

    }

    function moreDoughnut() {

        var newDoughnut = {
            backgroundColor :[],
            data: [],
            label: 'New Dataset' + configScore.data.datasets.length,
        };
        for (var i =0;i <configScore.data.labels.length;++i) {
            newDoughnut.backgroundColor.push(window.chartColors.green);
            newDoughnut.backgroundColor.push(window.chartColors.orange);
        }
        configScore.data.datasets.push(newDoughnut);
        window.myDoughnutScore.update();
    }



    function sumDatasets() {

        var newDatasetMag = {
            label: 'Sum ',
            borderWidth: 12,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(0,0,0)',
            borderColor: 'rgb(0,0,0)',
            data: [],
            pointRadius: 0,
            fill: false
        };

        var newDatasetPhase = {
            label: 'Sum ',
            borderWidth: 12,
            cubicInterpolationMode: 'monotone',
            backgroundColor: 'rgb(0,0,0)',
            borderColor: 'rgb(0,0,0)',
            data: [],
            pointRadius: 0,
            fill: false
        };

       var magNPhase = rebuild([],false);
       newDatasetMag.data= magNPhase[0];
       newDatasetPhase.data = magNPhase[1];


        configMag.data.datasets.push(newDatasetMag);
        window.myLineMag.update();
        configPhase.data.datasets.push(newDatasetPhase);
        window.myLinePhase.update();
        calculateScore();
    }


    function rebuild(arr, isArr){
        if (isArr === true){
            omega = arr;
        }
        else {

        var omega = omega_p1.concat(omega_z1,omega_p2,omega_z2,omega_cp,omega_cz);
        omega.sort((a, b) => a - b);
        omega.splice(0, omega.length, ...(new Set(omega)));
        }

        var mag_final =[];
        var phase_final =[];

        let mag_p1_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) mag_p1_y_f[i] = 0;
        let mag_z1_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) mag_z1_y_f[i] = 0;
        let mag_p2_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) mag_p2_y_f[i] = 0;
        let mag_z2_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) mag_z2_y_f[i] = 0;
        let mag_cp_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) mag_cp_y_f[i] = 0;
        let mag_cz_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) mag_cz_y_f[i] = 0;

        let phase_p1_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) phase_p1_y_f[i] = 0;
        let phase_z1_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) phase_z1_y_f[i] = 0;
        let phase_p2_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) phase_p2_y_f[i] = 0;
        let phase_z2_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) phase_z2_y_f[i] = 0;
        let phase_cp_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) phase_cp_y_f[i] = 0;
        let phase_cz_y_f = new Array(omega.length); for (let i=0; i<omega.length; ++i) phase_cz_y_f[i] = 0;

        //rebuild each input;
        for (var i=0; i<configMag.data.datasets.length; ++i) {
            switch (configMag.data.datasets[i].label) {
                case '1st order pole':
                    var mag_p1_y_t = [];
                    var phase_p1_y_t = [];
                    for (var j = 0; j < firstPoleInput.length; ++j) {
                        //var pole1 = document.getElementById('poleLoc1').value;
                        var omegac = -firstPoleInput[j];
                        var rebuildFirst_p = makeFirstOrder(omega, omegac, true)
                        var mag_p1 = rebuildFirst_p[0];
                        var phase_p1 = rebuildFirst_p[1];
                        var mag_p1_y = mag_p1.map(a => a.y);
                        var phase_p1_y = phase_p1.map(a => a.y);
                        mag_p1_y_t[j] = mag_p1_y;
                        phase_p1_y_t[j] = phase_p1_y;
                    }
                    mag_p1_y_f = addUpSameType(mag_p1_y_t);
                    phase_p1_y_f = addUpSameType(phase_p1_y_t);

                    break;


                case '1st order zero' :
                    //var zero1 = document.getElementById('zeroLoc1').value;
                    var mag_z1_y_t = [];
                    var phase_z1_y_t = [];
                    for (var k = 0; k < firstZeroInput.length; ++k) {
                        var omegac = -firstZeroInput[k];
                        var rebuildFirst_z = makeFirstOrder(omega, omegac, false)
                        var mag_z1 = rebuildFirst_z[0];
                        var phase_z1 = rebuildFirst_z[1];
                        var mag_z1_y = mag_z1.map(a => a.y);
                        var phase_z1_y = phase_z1.map(a => a.y);
                        mag_z1_y_t[k] = mag_z1_y;
                        phase_z1_y_t[k] = phase_z1_y;
                    }
                   mag_z1_y_f = addUpSameType(mag_z1_y_t);
                   phase_z1_y_f = addUpSameType( phase_z1_y_t);

                    break;

                case '2nd order pole':
                    //var pole_1 = -document.getElementById('poleLoc2_1').value;
                    //var pole_2 = -document.getElementById('poleLoc2_2').value;
                    var mag_p2_y_t = [];
                    var phase_p2_y_t = [];
                    for (var l = 0; l < secPoleInput.length; ++l) {
                        var pole_1 = secPoleInput[l].first;
                        var pole_2 = secPoleInput[l].second;
                        var naturalFreq_p2 = Math.pow(pole_1 * pole_2, 0.5);
                        var dampRatio_p2 = (-pole_2 - pole_1)/(2 * naturalFreq_p2);
                        var rebuildSec_p2 = makeSecondOrder(omega, naturalFreq_p2, dampRatio_p2, true);
                        var mag_p2 = rebuildSec_p2[0];
                        var phase_p2 = rebuildSec_p2[1];
                        var mag_p2_y = mag_p2.map(a => a.y);
                        var phase_p2_y = phase_p2.map(a => a.y);
                        mag_p2_y_t[l] = mag_p2_y;
                        phase_p2_y_t[l] = phase_p2_y;

                    }
                    mag_p2_y_f = addUpSameType( mag_p2_y_t);
                    phase_p2_y_f = addUpSameType(phase_p2_y_t);

                    break;
                case '2nd order zero':
                    //var zero_1 = -document.getElementById('zeroLoc2_1').value;
                    //var zero_2 = -document.getElementById('zeroLoc2_2').value;
                    var mag_z2_y_t = [];
                    var phase_z2_y_t = [];
                    for (var o = 0; o < secZeroInput.length; ++o) {
                        var zero_1 = secZeroInput[o].first;
                        var zero_2 = secZeroInput[o].second;
                        var naturalFreq_z2 = Math.pow(zero_1 * zero_2, 0.5);
                        var dampRatio_z2 = (-zero_2 - zero_1) / (2 * naturalFreq_z2);
                        var rebuildSec_z2 = makeSecondOrder(omega, naturalFreq_z2, dampRatio_z2, false);
                        var mag_z2 = rebuildSec_z2[0];
                        var phase_z2 = rebuildSec_z2[1];
                        var mag_z2_y = mag_z2.map(a => a.y);
                        var phase_z2_y = phase_z2.map(a => a.y);
                        mag_z2_y_t[o] = mag_z2_y;
                        phase_z2_y_t[o] = phase_z2_y;
                    }
                    mag_z2_y_f = addUpSameType(mag_z2_y_t);
                    phase_z2_y_f = addUpSameType( phase_z2_y_t);
                    break;

                case 'complex pole':
                    //var pole_cr = document.getElementById('cplxp_real').value;
                    //var pole_ci = document.getElementById('cplxp_ima').value;
                    var mag_cp_y_t = [];
                    var phase_cp_y_t = [];
                    for (var p = 0; p < compPoleInput.length; ++p) {
                        var pole_cr = compPoleInput[p].real;
                        var pole_ci = compPoleInput[p].imag;
                        var a_p = math.complex(pole_cr, pole_ci);
                        var b_p = math.complex(pole_cr, -pole_ci);
                        var naturalFreq_cp = Math.pow(math.multiply(a_p, b_p), 0.5);
                        var dampRatio_cp = pole_cr / (2 * naturalFreq_cp);
                        var rebuildSec_cp = makeSecondOrder(omega, naturalFreq_cp, dampRatio_cp, true);
                        var mag_cp = rebuildSec_cp[0];
                        var phase_cp = rebuildSec_cp[1];
                        var mag_cp_y = mag_cp.map(a => a.y);
                        var phase_cp_y = phase_cp.map(a => a.y);
                        mag_cp_y_t[p] = mag_cp_y;
                        phase_cp_y_t[p] = phase_cp_y;

                    }
                    mag_cp_y_f = addUpSameType(mag_cp_y_t);
                    phase_cp_y_f = addUpSameType(phase_cp_y_t);
                    break;

                case 'complex zero' :
                    //var zero_cr = document.getElementById('cplxz_real').value;
                    // var zero_ci = document.getElementById('cplxz_ima').value;
                    var mag_cz_y_t = [];
                    var phase_cz_y_t = [];
                    for (var q = 0; q < compZeroInput.length; ++q) {
                        var zero_cr = compZeroInput[q].real;
                        var zero_ci = compZeroInput[q].imag;
                        var a_z = math.complex(zero_cr, zero_ci);
                        var b_z = math.complex(zero_cr, -zero_ci);
                        var naturalFreq_cz = Math.pow(math.multiply(a_z, b_z), 0.5);
                        var dampRatio_cz = zero_cr / (2 * naturalFreq_cz);
                        var rebuildSec_cz = makeSecondOrder(omega, naturalFreq_cz, dampRatio_cz, false);
                        var mag_cz = rebuildSec_cz[0];
                        var phase_cz = rebuildSec_cz[1];
                        var mag_cz_y = mag_cz.map(a => a.y);
                        var phase_cz_y = phase_cz.map(a => a.y);
                        mag_cz_y_t[q] = mag_cz_y;
                        phase_cz_y_t[q] = phase_cz_y;
                        console.log(dampRatio_cz)
                        console.log(naturalFreq_cz)
                    }

                    mag_cz_y_f = addUpSameType( mag_cz_y_t);
                    phase_cz_y_f = addUpSameType(phase_cz_y_t);
                    break;

            }
        }
        // sum
        var len = omega.length;
        for (var r = 0; r < len; ++r ){
            var tempMag = mag_p1_y_f[r] + mag_z1_y_f[r] + mag_p2_y_f[r] + mag_z2_y_f[r] + mag_cp_y_f[r] +mag_cz_y_f[r];
            mag_final.push({x:omega[r], y:tempMag});

            var tempPhase = phase_p1_y_f[r] + phase_z1_y_f[r] + phase_p2_y_f[r] + phase_z2_y_f[r] + phase_cp_y_f[r] + phase_cz_y_f[r];
            phase_final.push({x:omega[r], y:tempPhase});
        }
        return [mag_final, phase_final]
    }

    function removeSumDataset(){
        configMag.data.datasets.splice(configMag.data.datasets.length-1, 1);
        window.myLineMag.update();

        configPhase.data.datasets.splice(configPhase.data.datasets.length-1, 1);
        window.myLinePhase.update();
    }

    function removeDataset(){

        if (configMag.data.datasets.length>2) {
            switch (configMag.data.datasets[configMag.data.datasets.length - 2].label){
                case '1st order pole':
                    firstPoleInput.splice(firstPoleInput.length-1,1);
                    break
                case '1st order zero' :
                    firstZeroInput.splice(firstZeroInput.length-1,1);
                    break
                case '2nd order pole':
                    secPoleInput.splice(secPoleInput.length-1,1);
                    break
                case '2nd order zero':
                    secZeroInput.splice(secZeroInput.length-1,1);
                    break
                case 'complex pole':
                    compPoleInput.splice(compPoleInput.length-1,1);
                    break
                case 'complex zero' :
                    compZeroInput.splice(compZeroInput.length-1,1);
                    break
            }

            configMag.data.datasets.splice(configMag.data.datasets.length - 2, 1);
            window.myLineMag.update();

            configPhase.data.datasets.splice(configPhase.data.datasets.length - 2, 1);
            window.myLinePhase.update();

            removeSumDataset();
            sumDatasets();
        }
        else {}
    }

    function removeAllDoughnut() {
        for (var i=0;i<=configScore.data.datasets.length+1;++i){
            configScore.data.datasets.splice(0,1);
        }
        window.myDoughnutScore.update();
    }

    function removeAll() {

        configMag.data.datasets=[];
        window.myLineMag.update();
        configPhase.data.datasets=[];
        window.myLinePhase.update();

    }

    function makeFirstOrder(omega,omegac,isPole) {
       var Mag = [];
       var Phase = [];

        if (isPole === true) {
            for (var i = 0; i < omega.length; ++i) {
                var tempMag = 1 / Math.sqrt(1 + Math.pow(omega[i], 2) * Math.pow((1 / omegac), 2));
                var tempMagdB = 20 * Math.log10(tempMag);
                var tempObjMag = {x: omega[i], y: tempMagdB};
                Mag.push(tempObjMag)

                var tempPhase = Math.atan2(-omega[i] / omegac, 1) * 180 / Math.PI;
                var tempObjPhase = {x: omega[i], y: tempPhase};
                Phase.push(tempObjPhase)

            }
        }
        else {
            for (var i = 0; i < omega.length; ++i) {
                var tempMag = Math.sqrt(1 + Math.pow(omega[i], 2) * Math.pow((1 / omegac), 2));
                var tempMagdB = 20 * Math.log10(tempMag);
                var tempObjMag = {x: omega[i], y: tempMagdB};
                Mag.push(tempObjMag)

                var tempPhase = Math.atan2(omega[i] / omegac, 1) * 180 / Math.PI;
                var tempObjPhase = {x: omega[i], y: tempPhase};
                Phase.push(tempObjPhase)
            }
        }
        return [Mag, Phase];
    }
    function makeSecondOrder(omega,naturalFreq,dampRatio,isPole) {
        var Mag = [];
        var Phase = [];

    if (isPole === true) {
        for (var i = 0; i < omega.length; ++i) {
            var tempMag = 1 / Math.sqrt(Math.pow(1 - Math.pow(omega[i] / naturalFreq, 2), 2) + Math.pow(2 * dampRatio * omega[i] / naturalFreq, 2));
            var tempMagdB = 20 * Math.log10(tempMag);
            var tempObjMag = {x: omega[i], y: tempMagdB};
            Mag.push(tempObjMag)

            var tempPhase = -Math.atan2(2 * dampRatio * omega[i] / naturalFreq, 1 - Math.pow(omega[i] / naturalFreq, 2)) * 180 / Math.PI;
            var tempObjPhase = {x: omega[i], y: tempPhase};
            Phase.push(tempObjPhase)
        }
    }
    else {
            for (var i = 0; i < omega.length; ++i) {
                var tempMag = Math.sqrt(Math.pow(1 - Math.pow(omega[i] / naturalFreq, 2), 2) + Math.pow(2 * dampRatio * omega[i] / naturalFreq, 2));
                var tempMagdB = 20 * Math.log10(tempMag);
                var tempObjMag = {x: omega[i], y: tempMagdB};
                Mag.push(tempObjMag)

                var tempPhase = Math.atan2(2 * dampRatio * omega[i] / naturalFreq, 1 - Math.pow(omega[i] / naturalFreq, 2)) * 180 / Math.PI;
                var tempObjPhase = {x: omega[i], y: tempPhase};
                Phase.push(tempObjPhase)

            }
        }
    return [Mag, Phase];
    }

    function addUpSameType(arr ) {
        let totalY = [];
            for(let j = 0;j<arr[0].length;++j){
                var tempSum= 0;
                for (let i = 0; i < arr.length; ++i) {
                    tempSum += arr[i][j]
            }
                totalY.push(tempSum)

        }

           return totalY

    }

    function resetInput(){
        firstPoleInput = [];
        firstZeroInput = [];
        secPoleInput = [];
        secZeroInput = [];
        compPoleInput = [];
        compZeroInput = [];
    }
    function changeTF(input1,input2){
        if (input2 === []){
        var newTF = "$$\\frac{(1)(s+)}$$"
        }
        else {

        }
        let OG = document.getElementById("transferFun");
        document.getElementById("transferFun").innerHTML = OG+ newTF;
        MathJax.typesetPromise()
    }

    </script>
    </body>
</html>